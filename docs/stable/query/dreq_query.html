<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>stable.query.dreq_query API documentation</title>
<meta name="description" content="Functions to extract information from the data request.
E.g., get variables requested for each experiment â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stable.query.dreq_query</code></h1>
</header>
<section id="section-intro">
<p>Functions to extract information from the data request.
E.g., get variables requested for each experiment.</p>
<p>The module has two basic sections:</p>
<p>1) Functions that take the data request content and convert it to python objects.
2) Functions that interrogate the data request, usually using output from (1) as their input.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="stable.query.dreq_query.create_dreq_tables_for_request"><code class="name flex">
<span>def <span class="ident">create_dreq_tables_for_request</span></span>(<span>content, consolidated=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_dreq_tables_for_request(content, consolidated=True):
    &#39;&#39;&#39;
    For the &#34;request&#34; part of the data request content (Opportunities, Variable Groups, etc),
    render raw airtable export content as dreq_table objects.

    For the &#34;data&#34; part of the data request, the corresponding function is create_dreq_tables_for_variables().

    Parameters
    ----------
    content : dict
        Raw airtable export. Dict is keyed by base name, for example:
        {&#39;Data Request Opportunities (Public)&#39; : {
            &#39;Opportunity&#39; : {...},
            ...
            },
         &#39;Data Request Variables (Public)&#39; : {
            &#39;Variables&#39; : {...}
            ...
            }
        }

    Returns
    -------
    Dict whose keys are table names and values are dreq_table objects.
    (The base name from the input &#39;content&#39; dict no longer appears.)
    &#39;&#39;&#39;
    if not isinstance(content, dict):
        raise TypeError(
            &#39;Input should be dict from raw airtable export json file&#39;)

    # Content is dict loaded from raw airtable export json file
    if consolidated:
        base_name = &#39;Data Request&#39;
        content_type = &#39;consolidated&#39;
    else:
        # for backward compatibility
        content_type = get_content_type(content)
        if content_type == &#39;working&#39;:
            base_name = &#39;Data Request Opportunities (Public)&#39;
        elif content_type == &#39;version&#39;:
            base_name = version_base_name()
        else:
            raise ValueError(&#39;Unknown content type: &#39; + content_type)
    # base_name = &#39;Data Request&#39;
    base = content[base_name]

    # Create objects representing data request tables
    table_id2name = get_table_id2name(base, base_name)
    for table_name, table in base.items():
        # print(&#39;Creating table object for table: &#39; + table_name)
        base[table_name] = dreq_table(table, table_id2name)

    # Change names of tables if needed
    # (insulates downstream code from upstream name changes that don&#39;t affect functionality)
    change_table_names = {}
    if content_type == &#39;working&#39;:
        change_table_names = {
            # old name : new name
            &#39;Experiment&#39;: &#39;Experiments&#39;,
            &#39;Priority level&#39;: &#39;Priority Level&#39;
        }
    for old, new in change_table_names.items():
        assert new not in base, &#39;New table name already exists: &#39; + new
        if old not in base:
            # print(f&#39;Unavailable table {old}, skipping name change&#39;)
            continue
        base[new] = base[old]
        base.pop(old)

    # Make some adjustments that are specific to the Opportunity table
    Opps = base[&#39;Opportunity&#39;]
    # rename title attribute for brevity in downstream code
    Opps.rename_attr(&#39;title_of_opportunity&#39;, &#39;title&#39;)
    for opp in Opps.records.values():
        opp.title = opp.title.strip()
    if content_type == &#39;working&#39;:
        if &#39;variable_groups&#39; not in Opps.attr2field:
            # Try alternate names for the latest variable groups
            try_vg_attr = []
            # takes precendence over originally requested groups
            try_vg_attr.append(&#39;working_updated_variable_groups&#39;)
            try_vg_attr.append(&#39;originally_requested_variable_groups&#39;)
            for vg_attr in try_vg_attr:
                if vg_attr in Opps.attr2field:
                    Opps.rename_attr(vg_attr, &#39;variable_groups&#39;)
                    break
            assert &#39;variable_groups&#39; in Opps.attr2field, f&#39;unable to determine variable groups attribute for opportunity: {opp.title}&#39;
    exclude_opps = set()
    for opp_id, opp in Opps.records.items():
        if not hasattr(opp, &#39;experiment_groups&#39;):
            print(
                f&#39; * WARNING *    no experiment groups found for Opportunity: {opp.title}&#39;)
            exclude_opps.add(opp_id)
        if not hasattr(opp, &#39;variable_groups&#39;):
            print(
                f&#39; * WARNING *    no variable groups found for Opportunity: {opp.title}&#39;)
            exclude_opps.add(opp_id)
    if len(exclude_opps) &gt; 0:
        print(&#39;Quality control check is excluding these Opportunities:&#39;)
        for opp_id in exclude_opps:
            opp = Opps.records[opp_id]
            print(f&#39;  {opp.title}&#39;)
            Opps.delete_record(opp_id)
        print()
    if len(Opps.records) == 0:
        # If there are no opportunities left, there&#39;s no point in continuing!
        # This check is here because if something changes upstream in Airtable, it might cause
        # the above code to erroneously remove all opportunities.
        raise Exception(&#39; * ERROR *    All Opportunities were removed!&#39;)

    return base</code></pre>
</details>
<div class="desc"><p>For the "request" part of the data request content (Opportunities, Variable Groups, etc),
render raw airtable export content as dreq_table objects.</p>
<p>For the "data" part of the data request, the corresponding function is create_dreq_tables_for_variables().</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code>dict</code></dt>
<dd>Raw airtable export. Dict is keyed by base name, for example:
{'Data Request Opportunities (Public)' : {
'Opportunity' : {&hellip;},
&hellip;
},
'Data Request Variables (Public)' : {
'Variables' : {&hellip;}
&hellip;
}
}</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict whose keys are table names and values are dreq_table objects.
(The base name from the input 'content' dict no longer appears.)</p></div>
</dd>
<dt id="stable.query.dreq_query.create_dreq_tables_for_variables"><code class="name flex">
<span>def <span class="ident">create_dreq_tables_for_variables</span></span>(<span>content, consolidated=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_dreq_tables_for_variables(content, consolidated=True):
    &#39;&#39;&#39;
    For the &#34;data&#34; part of the data request content (Variables, Cell Methods etc),
    render raw airtable export content as dreq_table objects.

    For the &#34;request&#34; part of the data request, the corresponding function is create_dreq_tables_for_request().

    &#39;&#39;&#39;
    if not isinstance(content, dict):
        raise TypeError(
            &#39;Input should be dict from raw airtable export json file&#39;)

    # Content is dict loaded from raw airtable export json file
    if consolidated:
        base_name = &#39;Data Request&#39;
        content_type = &#39;consolidated&#39;
    else:
        # for backward compatibility
        content_type = get_content_type(content)
        if content_type == &#39;working&#39;:
            base_name = &#39;Data Request Variables (Public)&#39;
        elif content_type == &#39;version&#39;:
            base_name = version_base_name()
        else:
            raise ValueError(&#39;Unknown content type: &#39; + content_type)
    base = content[base_name]

    # Create objects representing data request tables
    table_id2name = get_table_id2name(base, base_name)
    for table_name, table in base.items():
        # print(&#39;Creating table object for table: &#39; + table_name)
        base[table_name] = dreq_table(table, table_id2name)

    # Change names of tables if needed
    # (insulates downstream code from upstream name changes that don&#39;t affect functionality)
    change_table_names = {}
    if content_type == &#39;working&#39;:
        change_table_names = {
            # old name : new name
            &#39;Variable&#39;: &#39;Variables&#39;,
            &#39;Coordinate or Dimension&#39;: &#39;Coordinates and Dimensions&#39;,
            &#39;Physical Parameter&#39;: &#39;Physical Parameters&#39;,
        }
    for old, new in change_table_names.items():
        assert new not in base, &#39;New table name already exists: &#39; + new
        base[new] = base[old]
        base.pop(old)

    return base</code></pre>
</details>
<div class="desc"><p>For the "data" part of the data request content (Variables, Cell Methods etc),
render raw airtable export content as dreq_table objects.</p>
<p>For the "request" part of the data request, the corresponding function is create_dreq_tables_for_request().</p></div>
</dd>
<dt id="stable.query.dreq_query.get_content_type"><code class="name flex">
<span>def <span class="ident">get_content_type</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_type(content):
    &#39;&#39;&#39;
    Internal function to distinguish the type of airtable export we are working with, based on the input dict.

    Parameters
    ----------
    content : dict
        Dict containing data request content exported from airtable.

    Returns
    -------
    str indicating type of content:

        &#39;working&#39; : 3 bases containing the latest working version of data request content,
                    or 4 bases if the Schema table has been added to the export.

        &#39;version&#39; : 1 base containing the content of a tagged data request version.
    &#39;&#39;&#39;
    n = len(content)
    if n in [3, 4]:
        content_type = &#39;working&#39;
    elif n == 1:
        content_type = &#39;version&#39;
    else:
        raise ValueError(
            &#39;Unable to determine type of data request content in the exported json file&#39;)
    return content_type</code></pre>
</details>
<div class="desc"><p>Internal function to distinguish the type of airtable export we are working with, based on the input dict.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict containing data request content exported from airtable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str indicating type</code> of <code>content:</code></dt>
<dd>
<p>'working' : 3 bases containing the latest working version of data request content,
or 4 bases if the Schema table has been added to the export.</p>
<p>'version' : 1 base containing the content of a tagged data request version.</p>
</dd>
</dl></div>
</dd>
<dt id="stable.query.dreq_query.get_opp_expts"><code class="name flex">
<span>def <span class="ident">get_opp_expts</span></span>(<span>opp, ExptGroups, Expts, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_opp_expts(opp, ExptGroups, Expts, verbose=False):
    &#39;&#39;&#39;
    For one Opportunity, get its requested experiments.
    Input parameters are not modified.

    Parameters
    ----------
    opp : dreq_record
        One record from the Opportunity table
    ExptGroups : dreq_table
        Experiment Group table
    Expts : dreq_table
        Experiments table

    Returns
    -------
    Set giving names of experiments from which the Opportunity requests output.
    Example: {&#39;historical&#39;, &#39;piControl&#39;}
    &#39;&#39;&#39;
    # Follow links to experiment groups to find the names of requested experiments
    opp_expts = set()  # list to store names of experiments requested by this Opportunity
    if verbose:
        print(&#39;  Experiment Groups ({}):&#39;.format(len(opp.experiment_groups)))
    for link in opp.experiment_groups:
        # expt_group = base[link.table_name].records[link.record_id]
        expt_group = ExptGroups.records[link.record_id]

        if not hasattr(expt_group, &#39;experiments&#39;):
            continue

        if verbose:
            print(
                f&#39;    {expt_group.name}  ({len(expt_group.experiments)} experiments)&#39;)

        for link in expt_group.experiments:
            expt = Expts.records[link.record_id]
            # print(f&#39;  {expt.experiment}&#39;)
            opp_expts.add(expt.experiment)
    return opp_expts</code></pre>
</details>
<div class="desc"><p>For one Opportunity, get its requested experiments.
Input parameters are not modified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>opp</code></strong> :&ensp;<code>dreq_record</code></dt>
<dd>One record from the Opportunity table</dd>
<dt><strong><code>ExptGroups</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>Experiment Group table</dd>
<dt><strong><code>Expts</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>Experiments table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>Set giving names of experiments from which the Opportunity requests output.</dt>
<dt><strong><code>Example</code></strong> :&ensp;<code>{'historical', 'piControl'}</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="stable.query.dreq_query.get_opp_ids"><code class="name flex">
<span>def <span class="ident">get_opp_ids</span></span>(<span>use_opps, Opps, verbose=False, quality_control=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_opp_ids(use_opps, Opps, verbose=False, quality_control=True):
    &#39;&#39;&#39;
    Return list of unique opportunity identifiers.

    Parameters
    ----------
    use_opps : str or list
        &#34;all&#34; : return all available ids
        list of str : return ids for with the listed opportunity titles
    Opps : dreq_table
        table object representing the opportunities table
    &#39;&#39;&#39;
    opp_ids = []
    records = Opps.records
    if use_opps == &#39;all&#39;:
        # Include all opportunities
        opp_ids = list(records.keys())
    elif isinstance(use_opps, list):
        use_opps = sorted(set(use_opps))
        if all([isinstance(s, str) for s in use_opps]):
            # opp_ids = [opp_id for opp_id,opp in records.items() if opp.title in use_opps]
            title2id = {opp.title: opp_id for opp_id, opp in records.items()}
            assert len(records) == len(
                title2id), &#39;Opportunity titles are not unique&#39;
            for title in use_opps:
                if title in title2id:
                    opp_ids.append(title2id[title])
                else:
                    # print(f&#39;\n* WARNING *    Opportunity not found: {title}\n&#39;)
                    raise Exception(
                        f&#39;\n* ERROR *    The specified Opportunity is not found: {title}\n&#39;)

    assert len(set(opp_ids)) == len(opp_ids), &#39;found repeated opportunity ids&#39;

    if quality_control:
        valid_opp_status = [&#39;Accepted&#39;, &#39;Under review&#39;]
        discard_opp_id = set()
        for opp_id in opp_ids:
            opp = Opps.get_record(opp_id)
            # print(opp)
            # if len(opp) == 0:
            #     # discard empty opportunities
            #     discard_opp_id.add(opp_id)
            if hasattr(opp, &#39;status&#39;) and opp.status not in valid_opp_status:
                discard_opp_id.add(opp_id)
        for opp_id in discard_opp_id:
            Opps.delete_record(opp_id)
            opp_ids.remove(opp_id)
        del discard_opp_id

    if verbose:
        if len(opp_ids) &gt; 0:
            print(&#39;Found {} Opportunities:&#39;.format(len(opp_ids)))
            for opp_id in opp_ids:
                opp = records[opp_id]
                print(&#39;  &#39; + opp.title)
        else:
            print(&#39;No Opportunities found&#39;)

    return opp_ids</code></pre>
</details>
<div class="desc"><p>Return list of unique opportunity identifiers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>use_opps</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>"all" : return all available ids
list of str : return ids for with the listed opportunity titles</dd>
<dt><strong><code>Opps</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>table object representing the opportunities table</dd>
</dl></div>
</dd>
<dt id="stable.query.dreq_query.get_opp_vars"><code class="name flex">
<span>def <span class="ident">get_opp_vars</span></span>(<span>opp, priority_levels, VarGroups, Vars, PriorityLevel=None, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_opp_vars(opp, priority_levels, VarGroups, Vars, PriorityLevel=None, verbose=False):
    &#39;&#39;&#39;
    For one Opportunity, get its requested variables grouped by priority level.
    Input parameters are not modified.

    Parameters
    ----------
    opp : dreq_record
        One record from the Opportunity table
    priority_levels : list[str]
        Priority levels to get, example: [&#39;High&#39;, &#39;Medium&#39;]
    VarGroups : dreq_table
        Variable Group table
    Vars : dreq_table
        Variables table
    PriorityLevel : dreq_table
        Required if var_group.priority_level is link to PriorityLevel table 

    Returns
    -------
    Dict giving set of variables requested at each specified priority level
    Example: {&#39;High&#39; : {&#39;Amon.tas&#39;, &#39;day.tas&#39;}, &#39;Medium&#39; : {&#39;day.ua&#39;}}
    &#39;&#39;&#39;
    # Follow links to variable groups to find names of requested variables
    opp_vars = {p: set() for p in priority_levels}
    if verbose:
        print(&#39;  Variable Groups ({}):&#39;.format(len(opp.variable_groups)))
    for link in opp.variable_groups:
        var_group = VarGroups.records[link.record_id]

        priority_level = get_var_group_priority(var_group, PriorityLevel)
        if priority_level not in priority_levels:
            continue

        if verbose:
            print(
                f&#39;    {var_group.name}  ({len(var_group.variables)} variables, {priority_level} priority)&#39;)

        for link in var_group.variables:
            var = Vars.records[link.record_id]
            var_name = get_unique_var_name(var)
            # Add this variable to the list of requested variables at the specified priority
            opp_vars[priority_level].add(var_name)
    return opp_vars</code></pre>
</details>
<div class="desc"><p>For one Opportunity, get its requested variables grouped by priority level.
Input parameters are not modified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>opp</code></strong> :&ensp;<code>dreq_record</code></dt>
<dd>One record from the Opportunity table</dd>
<dt><strong><code>priority_levels</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Priority levels to get, example: ['High', 'Medium']</dd>
<dt><strong><code>VarGroups</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>Variable Group table</dd>
<dt><strong><code>Vars</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>Variables table</dd>
<dt><strong><code>PriorityLevel</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>Required if var_group.priority_level is link to PriorityLevel table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict giving set</code> of <code>variables requested at each specified priority level</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Example</code></strong> :&ensp;<code>{'High' : {'Amon.tas', 'day.tas'}, 'Medium' : {'day.ua'}}</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="stable.query.dreq_query.get_priority_levels"><code class="name flex">
<span>def <span class="ident">get_priority_levels</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_priority_levels():
    &#39;&#39;&#39;
    Return list of all valid priority levels (str) in the data request.
    List is ordered from highest to lowest priority.
    &#39;&#39;&#39;
    priority_levels = [s.capitalize() for s in PRIORITY_LEVELS]

    # The priorities are specified in PRIORITY_LEVELS from dreq_classes.
    # Check here that &#39;Core&#39; is highest priority.
    # The &#39;Core&#39; priority represents the Baseline Climate Variables (BCVs, https://doi.org/10.5194/egusphere-2024-2363).
    # It should be highest priority unless something has been mistakenly modified in dreq_classes.py.
    # Hence this check should NEVER fail, and is done here only to be EXTRA safe.
    assert priority_levels[
        0] == &#39;Core&#39;, &#39;error in PRIORITY_LEVELS: highest priority should be Core (BCVs)&#39;

    return priority_levels</code></pre>
</details>
<div class="desc"><p>Return list of all valid priority levels (str) in the data request.
List is ordered from highest to lowest priority.</p></div>
</dd>
<dt id="stable.query.dreq_query.get_requested_variables"><code class="name flex">
<span>def <span class="ident">get_requested_variables</span></span>(<span>content,<br>use_opps='all',<br>priority_cutoff='Low',<br>verbose=True,<br>consolidated=True,<br>check_core_variables=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_requested_variables(content, use_opps=&#39;all&#39;, priority_cutoff=&#39;Low&#39;, verbose=True, consolidated=True, check_core_variables=True):
    &#39;&#39;&#39;
    Return variables requested for each experiment, as a function of opportunities supported and priority level of variables.

    Parameters
    ----------
    content : dict
        Dict containing either:
        - data request content as exported from airtable
        OR
        - dreq_table objects representing tables (dict keys are table names)
    use_opp : str or list of str/int
        Identifies the opportunities being supported. Options:
            &#39;all&#39; : include all available opportunities
            integers : include opportunities identified by their integer IDs
            strings : include opportunities identified by their titles
    priority_cutoff : str
        Only return variables of equal or higher priority level than priority_cutoff.
        E.g., priority_cutoff=&#39;Low&#39; means all priority levels are returned.
    check_core_variables : bool
        True ==&gt; check that all experiments contain a non-empty list of Core variables,
        and that it&#39;s the same list for all experiments.

    Returns
    -------
    Dict keyed by experiment name, giving prioritized variables for each experiment.
    Example:
    {   &#39;Header&#39; : ... (Header contains info about where this request comes from)
        &#39;experiment&#39; : {
            &#39;historical&#39; :
                &#39;High&#39; : [&#39;Amon.tas&#39;, &#39;day.tas&#39;, ...],
                &#39;Medium&#39; : ...
            }
            ...
        }
    }
    &#39;&#39;&#39;
    if isinstance(content, dict):
        if all([isinstance(table, dreq_table) for table in content.values()]):
            # tables have already been rendered as dreq_table objects
            base = content
        else:
            # render tables as dreq_table objects
            base = create_dreq_tables_for_request(
                content, consolidated=consolidated)
    else:
        raise TypeError(&#39;Expect dict as input&#39;)

    Opps = base[&#39;Opportunity&#39;]
    opp_ids = get_opp_ids(use_opps, Opps, verbose=verbose)

    ExptGroups = base[&#39;Experiment Group&#39;]
    Expts = base[&#39;Experiments&#39;]
    VarGroups = base[&#39;Variable Group&#39;]
    Vars = base[&#39;Variables&#39;]

    # all_priority_levels = [&#39;Core&#39;, &#39;High&#39;, &#39;Medium&#39;, &#39;Low&#39;]
    # all_priority_levels = [s.capitalize() for s in PRIORITY_LEVELS]
    all_priority_levels = get_priority_levels()

    if &#39;Priority Level&#39; in base:
        PriorityLevel = base[&#39;Priority Level&#39;]
        priority_levels_from_table = [
            rec.name for rec in PriorityLevel.records.values()]
        assert set(all_priority_levels) == set(priority_levels_from_table), \
            &#39;inconsistent priority levels:\n  &#39; + \
            str(all_priority_levels) + &#39;\n  &#39; + str(priority_levels_from_table)
    else:
        PriorityLevel = None
    priority_cutoff = priority_cutoff.capitalize()
    if priority_cutoff not in all_priority_levels:
        raise ValueError(&#39;Invalid priority level cutoff: &#39; + priority_cutoff +
                         &#39;\nCould not determine priority levels to include.&#39;)
    m = all_priority_levels.index(priority_cutoff)
    priority_levels = all_priority_levels[:m+1]
    del priority_cutoff

    # Loop over Opportunities to get prioritized lists of variables
    request = {}  # dict to hold aggregated request
    for opp_id in opp_ids:
        opp = Opps.records[opp_id]  # one record from the Opportunity table

        if verbose:
            print(f&#39;Opportunity: {opp.title}&#39;)

        opp_expts = get_opp_expts(opp, ExptGroups, Expts, verbose=verbose)
        opp_vars = get_opp_vars(
            opp, priority_levels, VarGroups, Vars, PriorityLevel, verbose=verbose)

        # Aggregate this Opportunity&#39;s request into the master list of requests
        for expt_name in opp_expts:
            if expt_name not in request:
                # If we haven&#39;t encountered this experiment yet, initialize an expt_request object for it
                request[expt_name] = expt_request(expt_name)

            # Add this Opportunity&#39;s variables request to the expt_request object
            for priority_level, var_names in opp_vars.items():
                request[expt_name].add_vars(var_names, priority_level)

    opp_titles = sorted([Opps.get_record(opp_id).title for opp_id in opp_ids])
    requested_vars = {
        &#39;Header&#39;: {
            &#39;Opportunities&#39;: opp_titles,
            &#39;dreq version&#39;: DREQ_VERSION,
        },
        &#39;experiment&#39;: {},
    }
    for expt_name, expt_req in request.items():
        requested_vars[&#39;experiment&#39;].update(expt_req.to_dict())

    if check_core_variables:
        # Confirm that &#39;Core&#39; priority level variables are included, and identical for each experiment.
        # The setting of priority_levels list, above, should guarantee this.
        # Putting this extra check here just to be extra sure.
        core_vars = set()
        for expt_name, expt_req in requested_vars[&#39;experiment&#39;].items():
            assert &#39;Core&#39; in expt_req, &#39;Missing Core variables for experiment: &#39; + expt_name
            vars = set(expt_req[&#39;Core&#39;])
            assert len(
                vars) &gt; 0, &#39;Empty Core variables list for experiment: &#39; + expt_name
            if len(core_vars) == 0:
                core_vars = vars
            assert vars == core_vars, &#39;Inconsistent Core variables for experiment: &#39; + expt_name

    return requested_vars</code></pre>
</details>
<div class="desc"><p>Return variables requested for each experiment, as a function of opportunities supported and priority level of variables.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict containing either:
- data request content as exported from airtable
OR
- dreq_table objects representing tables (dict keys are table names)</dd>
<dt><strong><code>use_opp</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str/int</code></dt>
<dd>Identifies the opportunities being supported. Options:
'all' : include all available opportunities
integers : include opportunities identified by their integer IDs
strings : include opportunities identified by their titles</dd>
<dt><strong><code>priority_cutoff</code></strong> :&ensp;<code>str</code></dt>
<dd>Only return variables of equal or higher priority level than priority_cutoff.
E.g., priority_cutoff='Low' means all priority levels are returned.</dd>
<dt><strong><code>check_core_variables</code></strong> :&ensp;<code>bool</code></dt>
<dd>True ==&gt; check that all experiments contain a non-empty list of Core variables,
and that it's the same list for all experiments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>Dict keyed by experiment name, giving prioritized variables for each experiment.</dt>
<dt><code>Example:</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>{
'Header' : &hellip; (Header contains info about where this request comes from)
'experiment' : {
'historical' :
'High' : ['Amon.tas', 'day.tas', &hellip;],
'Medium' : &hellip;
}
&hellip;
}
}</p></div>
</dd>
<dt id="stable.query.dreq_query.get_table_id2name"><code class="name flex">
<span>def <span class="ident">get_table_id2name</span></span>(<span>base, base_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_table_id2name(base, base_name):
    &#39;&#39;&#39;
    Get a mapping from table id to table name
    &#39;&#39;&#39;
    table_id2name = {}
    for table_name, table in base.items():
        # assert table[&#39;name&#39;] == table_name
        # assert table[&#39;base_name&#39;] == base_name, table[&#39;base_name&#39;] + &#39;, &#39; + base_name
        table_id2name.update({
            table[&#39;id&#39;]: table[&#39;name&#39;]
        })
    assert len(table_id2name) == len(base), &#39;table ids are not unique!&#39;
    return table_id2name</code></pre>
</details>
<div class="desc"><p>Get a mapping from table id to table name</p></div>
</dd>
<dt id="stable.query.dreq_query.get_unique_var_name"><code class="name flex">
<span>def <span class="ident">get_unique_var_name</span></span>(<span>var)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unique_var_name(var):
    &#39;&#39;&#39;
    Return name that uniquely identifies a variable.
    Reason to make this a function is to control this choice in one place.
    E.g., if compound_name is used initially, but something else chosen later.

    Parameters
    ----------
    var : dreq_record
        Object representing a variable

    Returns
    -------
    str that uniquely identifes a variable in the data request
    &#39;&#39;&#39;
    if UNIQUE_VAR_NAME == &#39;compound name&#39;:
        return var.compound_name
    else:
        raise ValueError(&#39;Unknown identifier for UNIQUE_VAR_NAME: &#39; + UNIQUE_VAR_NAME +
                         &#39;\nHow should the unique variable name be determined?&#39;)</code></pre>
</details>
<div class="desc"><p>Return name that uniquely identifies a variable.
Reason to make this a function is to control this choice in one place.
E.g., if compound_name is used initially, but something else chosen later.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;<code>dreq_record</code></dt>
<dd>Object representing a variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str that uniquely identifes a variable in the data request</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="stable.query.dreq_query.get_var_group_priority"><code class="name flex">
<span>def <span class="ident">get_var_group_priority</span></span>(<span>var_group, PriorityLevel=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var_group_priority(var_group, PriorityLevel=None):
    &#39;&#39;&#39;
    Returns string stating the priorty level of variable group.

    Parameters
    ----------
    var_group : dreq_record
        Object representing a variable group
        Its &#34;priority_level&#34; attribute specifies the priority as either string or link to PriorityLevel table 
    PriorityLevel : dreq_table
        Required if var_group.priority_level is link to PriorityLevel table 

    Returns
    -------
    str that states the priority level, e.g. &#34;High&#34;
    &#39;&#39;&#39;
    if not hasattr(var_group, &#39;priority_level&#39;):
        return &#39;Undefined&#39;

    if isinstance(var_group.priority_level, list):
        assert len(
            var_group.priority_level) == 1, &#39;Variable group should have one specified priority level&#39;
        link = var_group.priority_level[0]
        assert isinstance(PriorityLevel, dreq_table)
        rec = PriorityLevel.records[link.record_id]
        priority_level = rec.name
    elif isinstance(var_group.priority_level, str):
        priority_level = var_group.priority_level
    else:
        raise Exception(&#39;Unable to determine variable group priority level&#39;)
    if not isinstance(priority_level, str):
        raise TypeError(
            &#39;Priority level should be str, instead got {}&#39;.format(type(priority_level)))
    return priority_level</code></pre>
</details>
<div class="desc"><p>Returns string stating the priorty level of variable group.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>var_group</code></strong> :&ensp;<code>dreq_record</code></dt>
<dd>Object representing a variable group
Its "priority_level" attribute specifies the priority as either string or link to PriorityLevel table</dd>
<dt><strong><code>PriorityLevel</code></strong> :&ensp;<code>dreq_table</code></dt>
<dd>Required if var_group.priority_level is link to PriorityLevel table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str that states the priority level, e.g. "High"</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="stable.query.dreq_query.show_requested_vars_summary"><code class="name flex">
<span>def <span class="ident">show_requested_vars_summary</span></span>(<span>expt_vars, use_dreq_version)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_requested_vars_summary(expt_vars, use_dreq_version):
    &#39;&#39;&#39;
    Display quick summary to stdout of variables requested.
    expt_vars is the output dict from dq.get_requested_variables().
    &#39;&#39;&#39;
    print(
        f&#39;\nFor data request version {use_dreq_version}, number of requested variables found by experiment:&#39;)
    priority_levels = get_priority_levels()
    for expt, req in sorted(expt_vars[&#39;experiment&#39;].items()):
        d = {p: 0 for p in priority_levels}
        for p in priority_levels:
            if p in req:
                d[p] = len(req[p])
        n_total = sum(d.values())
        print(f&#39;  {expt} : &#39; + &#39; ,&#39;.join([&#39;{p}={n}&#39;.format(p=p, n=d[p])
              for p in priority_levels]) + f&#39;, TOTAL={n_total}&#39;)</code></pre>
</details>
<div class="desc"><p>Display quick summary to stdout of variables requested.
expt_vars is the output dict from dq.get_requested_variables().</p></div>
</dd>
<dt id="stable.query.dreq_query.version_base_name"><code class="name flex">
<span>def <span class="ident">version_base_name</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def version_base_name():
    return f&#39;Data Request {DREQ_VERSION}&#39;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="stable.query.dreq_query.write_requested_vars_json"><code class="name flex">
<span>def <span class="ident">write_requested_vars_json</span></span>(<span>outfile, expt_vars, use_dreq_version, priority_cutoff, content_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_requested_vars_json(outfile, expt_vars, use_dreq_version, priority_cutoff, content_path):
    &#39;&#39;&#39;
    Write a nicely formatted json file with lists of requested variables by experiment.
    expt_vars is the output dict from dq.get_requested_variables().
    &#39;&#39;&#39;

    Header = OrderedDict({
        &#39;Description&#39;: &#39;This file gives the names of output variables that are requested from CMIP experiments by the supported Opportunities. The variables requested from each experiment are listed under each experiment name, grouped according to the priority level at which they are requested. For each experiment, the prioritized list of variables was determined by compiling together all requests made by the supported Opportunities for output from that experiment.&#39;,
        &#39;Opportunities supported&#39;: sorted(expt_vars[&#39;Header&#39;][&#39;Opportunities&#39;], key=str.lower)
    })

    # List supported priority levels
    priority_levels = get_priority_levels()
    priority_cutoff = priority_cutoff.capitalize()
    m = priority_levels.index(priority_cutoff)+1
    Header.update({
        &#39;Priority levels supported&#39;: priority_levels[:m]
    })
    for req in expt_vars[&#39;experiment&#39;].values():
        for p in priority_levels[m:]:
            assert req[p] == []
            # remove empty lists of unsupported priorities from the output
            req.pop(p)

    # List included experiments
    Header.update({
        &#39;Experiments included&#39;: sorted(expt_vars[&#39;experiment&#39;].keys(), key=str.lower)
    })

    # Get provenance of content to include in the Header
    # content_path = dc._dreq_content_loaded[&#39;json_path&#39;]
    with open(content_path, &#39;rb&#39;) as f:
        content_hash = hashlib.sha256(f.read()).hexdigest()
    Header.update({
        &#39;dreq content version&#39;: use_dreq_version,
        &#39;dreq content file&#39;: os.path.basename(os.path.normpath(content_path)),
        &#39;dreq content sha256 hash&#39;: content_hash,
        &#39;dreq api version&#39;: api_version,
    })

    out = {
        &#39;Header&#39;: Header,
        &#39;experiment&#39;: OrderedDict(),
    }
    expt_names = sorted(expt_vars[&#39;experiment&#39;].keys(), key=str.lower)
    for expt_name in expt_names:
        out[&#39;experiment&#39;][expt_name] = OrderedDict()
        req = expt_vars[&#39;experiment&#39;][expt_name]
        for p in priority_levels:
            if p in req:
                out[&#39;experiment&#39;][expt_name][p] = req[p]

    # Write the results to json
    with open(outfile, &#39;w&#39;) as f:
        # json.dump(expt_vars, f, indent=4, sort_keys=True)
        json.dump(out, f, indent=4)
        print(&#39;\nWrote requested variables to &#39; + outfile)</code></pre>
</details>
<div class="desc"><p>Write a nicely formatted json file with lists of requested variables by experiment.
expt_vars is the output dict from dq.get_requested_variables().</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stable.query" href="index.html">stable.query</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="stable.query.dreq_query.create_dreq_tables_for_request" href="#stable.query.dreq_query.create_dreq_tables_for_request">create_dreq_tables_for_request</a></code></li>
<li><code><a title="stable.query.dreq_query.create_dreq_tables_for_variables" href="#stable.query.dreq_query.create_dreq_tables_for_variables">create_dreq_tables_for_variables</a></code></li>
<li><code><a title="stable.query.dreq_query.get_content_type" href="#stable.query.dreq_query.get_content_type">get_content_type</a></code></li>
<li><code><a title="stable.query.dreq_query.get_opp_expts" href="#stable.query.dreq_query.get_opp_expts">get_opp_expts</a></code></li>
<li><code><a title="stable.query.dreq_query.get_opp_ids" href="#stable.query.dreq_query.get_opp_ids">get_opp_ids</a></code></li>
<li><code><a title="stable.query.dreq_query.get_opp_vars" href="#stable.query.dreq_query.get_opp_vars">get_opp_vars</a></code></li>
<li><code><a title="stable.query.dreq_query.get_priority_levels" href="#stable.query.dreq_query.get_priority_levels">get_priority_levels</a></code></li>
<li><code><a title="stable.query.dreq_query.get_requested_variables" href="#stable.query.dreq_query.get_requested_variables">get_requested_variables</a></code></li>
<li><code><a title="stable.query.dreq_query.get_table_id2name" href="#stable.query.dreq_query.get_table_id2name">get_table_id2name</a></code></li>
<li><code><a title="stable.query.dreq_query.get_unique_var_name" href="#stable.query.dreq_query.get_unique_var_name">get_unique_var_name</a></code></li>
<li><code><a title="stable.query.dreq_query.get_var_group_priority" href="#stable.query.dreq_query.get_var_group_priority">get_var_group_priority</a></code></li>
<li><code><a title="stable.query.dreq_query.show_requested_vars_summary" href="#stable.query.dreq_query.show_requested_vars_summary">show_requested_vars_summary</a></code></li>
<li><code><a title="stable.query.dreq_query.version_base_name" href="#stable.query.dreq_query.version_base_name">version_base_name</a></code></li>
<li><code><a title="stable.query.dreq_query.write_requested_vars_json" href="#stable.query.dreq_query.write_requested_vars_json">write_requested_vars_json</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
