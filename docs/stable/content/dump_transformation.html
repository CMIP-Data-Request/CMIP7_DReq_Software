<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>stable.content.dump_transformation API documentation</title>
<meta name="description" content="Script to change the basic airtable export into readable files.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stable.content.dump_transformation</code></h1>
</header>
<section id="section-intro">
<p>Script to change the basic airtable export into readable files.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="stable.content.dump_transformation.correct_dictionaries"><code class="name flex">
<span>def <span class="ident">correct_dictionaries</span></span>(<span>input_dict, is_record_ids=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_dictionaries(input_dict, is_record_ids=False):
    &#34;&#34;&#34;
    Correct the input_dict to correct the strings except the record ids.
    :param dict input_dict: the input dictionary to be corrected
    :param bool is_record_ids: a boolean to indicate whether the keys of input_dict contain record ids or not
    :return dict: the corrected dictionary
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(input_dict, dict):
        rep = dict()
        for (key, value) in input_dict.items():
            if not is_record_ids:
                new_key = correct_key_string(key)
            else:
                new_key = key
            if isinstance(value, dict):
                rep[new_key] = correct_dictionaries(
                    value, is_record_ids=key in [&#34;records&#34;, &#34;fields&#34;])
            else:
                rep[new_key] = copy.deepcopy(value)
        return rep
    else:
        logger.error(f&#34;Deal with dict types, not {type(input_dict).__name__}&#34;)
        raise TypeError(
            f&#34;Deal with dict types, not {type(input_dict).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Correct the input_dict to correct the strings except the record ids.
:param dict input_dict: the input dictionary to be corrected
:param bool is_record_ids: a boolean to indicate whether the keys of input_dict contain record ids or not
:return dict: the corrected dictionary</p></div>
</dd>
<dt id="stable.content.dump_transformation.correct_key_string"><code class="name flex">
<span>def <span class="ident">correct_key_string</span></span>(<span>input_string, *to_remove_strings)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_key_string(input_string, *to_remove_strings):
    &#34;&#34;&#34;
    Change the input string by replacing &#39;&amp;&#39; by &#39;and&#39; and spaces by underscores.
    It also removes others specified strings.
    :param str input_string: the input string to be changed
    :param list of str to_remove_strings: the list of strings to be removed from input_string
    :return str: the changed string
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(input_string, str):
        input_string = input_string.lower()
        for to_remove_string in to_remove_strings:
            input_string = input_string.replace(to_remove_string.lower(), &#34;&#34;)
        input_string = input_string.strip()
        input_string = input_string.replace(&#34;&amp;&#34;, &#34;and&#34;).replace(&#34; &#34;, &#34;_&#34;)
    else:
        logger.error(
            f&#34;Deal with string types, not {type(input_string).__name__}&#34;)
        raise TypeError(
            f&#34;Deal with string types, not {type(input_string).__name__}&#34;)
    return input_string</code></pre>
</details>
<div class="desc"><p>Change the input string by replacing '&amp;' by 'and' and spaces by underscores.
It also removes others specified strings.
:param str input_string: the input string to be changed
:param list of str to_remove_strings: the list of strings to be removed from input_string
:return str: the changed string</p></div>
</dd>
<dt id="stable.content.dump_transformation.get_transformed_content"><code class="name flex">
<span>def <span class="ident">get_transformed_content</span></span>(<span>version='latest_stable',<br>export_version='release',<br>use_consolidation=False,<br>force_retrieve=False,<br>output_dir=None,<br>default_transformed_content_pattern='{kind}_{export_version}_content.json')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transformed_content(version=&#34;latest_stable&#34;, export_version=&#34;release&#34;, use_consolidation=False,
                            force_retrieve=False, output_dir=None,
                            default_transformed_content_pattern=&#34;{kind}_{export_version}_content.json&#34;):
    # Download specified version of data request content (if not locally cached)
    versions = dc.retrieve(version, export=export_version,
                           consolidate=use_consolidation)

    # Check that there is only one version associated
    if len(versions) &gt; 1:
        raise ValueError(&#34;Could only deal with one version.&#34;)
    elif len(versions) == 0:
        raise ValueError(&#34;No version found.&#34;)
    else:
        version = list(versions)[0]
        content = versions[version]
        if output_dir is None:
            output_dir = os.path.dirname(content)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        DR_content = default_transformed_content_pattern.format(
            kind=&#34;DR&#34;, export_version=export_version)
        VS_content = default_transformed_content_pattern.format(
            kind=&#34;VS&#34;, export_version=export_version)
        DR_content = os.sep.join([output_dir, DR_content])
        VS_content = os.sep.join([output_dir, VS_content])
        if force_retrieve or not (all(os.path.exists(filepath) for filepath in [DR_content, VS_content])):
            if os.path.exists(DR_content):
                os.remove(DR_content)
            if os.path.exists(VS_content):
                os.remove(VS_content)
        if not (all(os.path.exists(filepath) for filepath in [DR_content, VS_content])):
            content = dc.load(version, export=export_version,
                              consolidate=use_consolidation)
            data_request, vocabulary_server = transform_content(
                content, version)
            write_json_output_file_content(DR_content, data_request)
            write_json_output_file_content(VS_content, vocabulary_server)
        return DR_content, VS_content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="stable.content.dump_transformation.split_content_one_base"><code class="name flex">
<span>def <span class="ident">split_content_one_base</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_content_one_base(content):
    &#34;&#34;&#34;
    Split the one base content into two dictionaries:
    - the DR (structure)
    - the VS (vocabulary server with all information)
    :param dict content: dictionary containing the one base content
    :return dict, dict: two dictionaries containing respectively the DR and VS
    &#34;&#34;&#34;
    logger = get_logger()
    data_request = defaultdict(lambda: defaultdict(
        lambda: defaultdict(lambda: dict)))
    keys_to_dr_dict = {
        &#34;opportunities&#34;: [(&#34;experiment_groups&#34;, list, list()),
                          (&#34;variable_groups&#34;, list, list()),
                          (&#34;data_request_themes&#34;, list, list()),
                          (&#34;time_subset&#34;, list, list()),
                          (&#34;mips&#34;, list, list())],
        &#34;variable_groups&#34;: [(&#34;variables&#34;, list, list()),
                            (&#34;mips&#34;, list, list()),
                            (&#34;priority_level&#34;, (str, type(None)), None)],
        &#34;experiment_groups&#34;: [(&#34;experiments&#34;, list, list()), ]
    }
    if isinstance(content, dict):
        logger.debug(&#34;Build DR and VS&#34;)
        for subelt in sorted(list(content)):
            if subelt in keys_to_dr_dict:
                for uid in content[subelt]:
                    for (key, target_type, default) in keys_to_dr_dict[subelt]:
                        value = content[subelt][uid].pop(key, default)
                        if not isinstance(value, target_type):
                            if target_type in [list, ] and isinstance(value, (str, int, type(None))):
                                value = [value, ]
                            elif str in target_type and isinstance(value, list):
                                value = value[0]
                            else:
                                raise TypeError(
                                    f&#34;Could not deal with target type {type(target_type)}&#34;)
                        data_request[subelt][uid][key] = value
        return data_request, content
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Split the one base content into two dictionaries:
- the DR (structure)
- the VS (vocabulary server with all information)
:param dict content: dictionary containing the one base content
:return dict, dict: two dictionaries containing respectively the DR and VS</p></div>
</dd>
<dt id="stable.content.dump_transformation.transform_content"><code class="name flex">
<span>def <span class="ident">transform_content</span></span>(<span>content, version)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_content(content, version):
    &#34;&#34;&#34;
    Function to transform the export content (single or several base-s- export) to VS and DR dictionaries.
    The key &#34;version&#34; is added to the DR and VS dictionaries.
    :param dict content: input export content (either single base or several bases)
    :param str version: string containing the version of the export content
    :return dict, dict: DR and VS dictionaries containing respectively the structure (DR) and the vocabulary (VS)
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(content, dict):
        # Get back to one database case if needed
        if len(content) == 1:
            logger.info(
                &#34;Single database case - no structure transformation needed&#34;)
        elif len(content) in [3, 4]:
            logger.info(
                &#34;Several databases case - structure transformation needed&#34;)
            content = transform_content_three_bases(content)
        else:
            raise ValueError(
                f&#34;Could not manage the {len(content):d} bases export file.&#34;)
        # Correct dictionaries
        content = correct_dictionaries(content)
        # Change several attributes
        content = transform_content_one_base(content)
        # Separate DR and VS files
        data_request, vocabulary_server = split_content_one_base(content)
        data_request[&#34;version&#34;] = version
        vocabulary_server[&#34;version&#34;] = version
        return data_request, vocabulary_server
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Function to transform the export content (single or several base-s- export) to VS and DR dictionaries.
The key "version" is added to the DR and VS dictionaries.
:param dict content: input export content (either single base or several bases)
:param str version: string containing the version of the export content
:return dict, dict: DR and VS dictionaries containing respectively the structure (DR) and the vocabulary (VS)</p></div>
</dd>
<dt id="stable.content.dump_transformation.transform_content_one_base"><code class="name flex">
<span>def <span class="ident">transform_content_one_base</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_content_one_base(content):
    &#34;&#34;&#34;
    Transform a one base export content to:
    - remove unused keys which could create circle import later
    - harmonise some entries
    - reshape entries if needed
    - remove elements which are not used
    - filter content on status
    :param dict content: one base content export (direct export or created from `transform_content_three_bases`
    :return dict: the transform content
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(content, dict) and len(content) == 1:
        default_count = 0
        default_template = &#34;default_{:d}&#34;
        content = content[list(content)[0]]
        # Rename some elements
        esm_bcv_regexp = re.compile(r&#34;esm-bcv.*&#34;)
        esm_bcv = [elt for elt in list(content) if esm_bcv_regexp.match(elt)]
        if len(esm_bcv) == 1:
            esm_bcv = esm_bcv[0]
            content[&#34;esm-bcv&#34;] = content.pop(esm_bcv)
        for (key, new_key) in [(&#34;opportunity&#34;, &#34;opportunities&#34;), (&#34;experiment_group&#34;, &#34;experiment_groups&#34;),
                               (&#34;variable_group&#34;, &#34;variable_groups&#34;), (&#34;structure&#34;,
                                                                       &#34;structure_title&#34;),
                               (&#34;time_slice&#34;, &#34;time_subset&#34;)]:
            if key in content:
                content[new_key] = content.pop(key)
        for pattern in [&#34;.*rank.*&#34;, ]:
            elts = [elt for elt in list(
                content) if re.compile(pattern).match(elt)]
            for elt in elts:
                del content[elt]
        for pattern in [&#34;(legacy)&#34;, ]:
            for elt in [elt for elt in list(content) if pattern in elt]:
                new_elt = elt.replace(pattern, &#34;&#34;).strip(&#34;_&#34;)
                content[new_elt] = content.pop(elt)
        # Tidy the content of the export file
        default_patterns_to_remove = [r&#34;.*\(from.*\).*&#34;, r&#34;.*proposed.*&#34;, r&#34;.*review.*&#34;, r&#34;.*--.*&#34;,
                                      r&#34;.*created.*&#34;, r&#34;.*rank.*&#34;, &#34;.*count.*&#34;, &#34;.*alert.*&#34;, &#34;.*tagged.*&#34;, &#34;.*unique.*&#34;,
                                      &#34;last_modified.*&#34;, &#34;.*validation.*&#34;, &#34;.*number.*&#34;, &#34;.*mj.*&#34;, r&#34;.*proposal.*&#34;]
        to_remove_keys_patterns = {
            &#34;cell_measures&#34;: [r&#34;variables&#34;, &#34;structure&#34;],
            &#34;cell_methods&#34;: [r&#34;structure&#34;, r&#34;variables&#34;],
            &#34;cf_standard_names&#34;: [r&#34;physical_parameters.*&#34;, &#34;esm-bcv.*&#34;],
            &#34;cmip6_frequency&#34;: [r&#34;table_identifiers.*&#34;, r&#34;variables.*&#34;],
            &#34;cmip7_frequency&#34;: [r&#34;table_identifiers.*&#34;, r&#34;variables.*&#34;],
            &#34;coordinates_and_dimensions&#34;: [r&#34;spatial_shape&#34;, r&#34;structure&#34;, &#34;temporal_shape&#34;, &#34;variables&#34;, &#34;size&#34;],
            &#34;data_request_themes&#34;: [r&#34;experiment_group.*&#34;, r&#34;.*opportunit.*&#34;, r&#34;variable_group.*&#34;],
            &#34;esm-bcv&#34;: [r&#34;v\d.*&#34;, &#34;cf_standard_name&#34;, &#34;.*variables&#34;],
            &#34;experiment_groups&#34;: [r&#34;opportunit.*&#34;, r&#34;theme.*&#34;, &#34;comments.+&#34;],
            &#34;experiments&#34;: [r&#34;experiment_group.*&#34;, r&#34;opportunit.*&#34;, &#34;variables&#34;, &#34;mip&#34;],
            &#34;glossary&#34;: [&#34;opportunit.*&#34;, ],
            &#34;mips&#34;: [&#34;variable_group.*&#34;, &#34;experiments.*&#34;, &#34;.*opportunit.*&#34;, &#34;variables&#34;],
            &#34;modelling_realm&#34;: [&#34;variables&#34;, ],
            &#34;opportunities&#34;: [&#34;.*data_volume_estimate&#34;, &#34;opportunity_id&#34;, &#34;originally_requested_variable_groups&#34;],
            &#34;opportunity/variable_group_comments&#34;: [&#34;experiment_groups&#34;, &#34;opportunities&#34;, &#34;theme&#34;, &#34;variable_groups&#34;],
            &#34;physical_parameters&#34;: [&#34;variables&#34;, &#34;conditional&#34;, &#34;does_a_cf.*&#34;],
            &#34;physical_parameter_comments&#34;: [&#34;physical_parameters&#34;, &#34;does_a.*&#34;, &#34;cf_standard_names&#34;, &#34;physical_parameters&#34;],
            &#34;priority_level&#34;: [&#34;variable_group&#34;, ],
            &#34;spatial_shape&#34;: [r&#34;dimensions.*&#34;, r&#34;structure.*&#34;, r&#34;.*variables.*&#34;, &#34;hor.*&#34;, &#34;vert.*&#34;],
            &#34;structure_title&#34;: [r&#34;variables.*&#34;, &#34;brand_.*&#34;, &#34;calculation.*&#34;],
            &#34;table_identifiers&#34;: [&#34;variables&#34;, ],
            &#34;temporal_shape&#34;: [&#34;variables&#34;, &#34;structure&#34;],
            &#34;time_subset&#34;: [&#34;uid.+&#34;, &#34;opportunit.*&#34;],
            &#34;variable_comments&#34;: [&#34;variable.*&#34;, &#34;spatial_shape&#34;, &#34;temporal_shape&#34;, &#34;coordinates_and_dimensions&#34;,
                                  &#34;cell_methods&#34;, &#34;cell_measures&#34;],
            &#34;variable_groups&#34;: [&#34;.*opportunit.*&#34;, &#34;theme&#34;, r&#34;size.*&#34;, &#34;mip_ownership&#34;],
            &#34;variables&#34;: [r&#34;priority.*&#34;, r&#34;.*variable_group.*&#34;, &#34;.*experiment.*&#34;, &#34;size&#34;, &#34;vertical_dimension&#34;,
                          &#34;temporal_sampling_rate&#34;, &#34;horizontal_mesh&#34;, r&#34;brand.*\[link\]&#34;, &#34;structure_label&#34;,
                          &#34;table_section.*&#34;, &#34;theme&#34;],
        }
        to_rename_keys_patterns = {
            &#34;cell_methods&#34;: [(&#34;comments&#34;, &#34;variable_comments&#34;), (&#34;label&#34;, &#34;name&#34;)],
            &#34;cf_standard_names&#34;: [(&#34;comments&#34;, &#34;physical_parameter_comments&#34;)],
            &#34;cmip7_frequency&#34;: [(&#34;cmip6_frequency.*&#34;, &#34;cmip6_frequency&#34;)],
            &#34;coordinates_and_dimensions&#34;: [(&#34;requested_bounds.+&#34;, &#34;requested_bounds&#34;), (&#34;comments&#34;, &#34;variable_comments&#34;)],
            &#34;data_request_themes&#34;: [(&#34;comments&#34;, &#34;opportunity/variable_group_comments&#34;), (&#34;uid.+&#34;, &#34;uid&#34;)],
            &#34;experiments&#34;: [(&#34;experiment&#34;, &#34;name&#34;)],
            &#34;experiment_groups&#34;: [(&#34;comments&#34;, &#34;opportunity/variable_group_comments&#34;)],
            &#34;modelling_realm&#34;: [(&#34;id&#34;, &#34;uid&#34;)],
            &#34;opportunities&#34;: [(&#34;title_of_opportunity&#34;, &#34;name&#34;), (&#34;comments&#34;, &#34;opportunity/variable_group_comments&#34;),
                              (&#34;ensemble_size&#34;, &#34;minimum_ensemble_size&#34;), (&#34;themes&#34;,
                                                                           &#34;data_request_themes&#34;),
                              (&#34;working/updated_variable_groups&#34;, &#34;variable_groups&#34;), (&#34;time_slice&#34;, &#34;time_subset&#34;)],
            &#34;physical_parameters&#34;: [(&#34;comments&#34;, &#34;physical_parameter_comments&#34;),
                                    (&#34;cf_proposal_github_issue&#34;,
                                     &#34;proposal_github_issue&#34;),
                                    (&#34;flag.*change.*&#34;, &#34;flag_change_since_cmip6&#34;)],
            &#34;spatial_shape&#34;: [(&#34;comments&#34;, &#34;variable_comments&#34;)],
            &#34;temporal_shape&#34;: [(&#34;comments&#34;, &#34;variable_comments&#34;)],
            &#34;structure_title&#34;: [(&#34;label&#34;, &#34;name&#34;)],
            &#34;table_identifiers&#34;: [(&#34;comment&#34;, &#34;notes&#34;), (&#34;frequency&#34;, &#34;cmip6_frequency&#34;)],
            &#34;time_subset&#34;: [(&#34;label&#34;, &#34;name&#34;)],
            &#34;variable_groups&#34;: [(&#34;.*mips.*&#34;, &#34;mips&#34;), (&#34;comments&#34;, &#34;opportunity/variable_group_comments&#34;)],
            &#34;variables&#34;: [(&#34;compound_name&#34;, &#34;name&#34;), (&#34;cmip6_frequency.+&#34;, &#34;cmip6_frequency&#34;), (esm_bcv, &#34;esm-bcv&#34;),
                          (&#34;modeling_realm&#34;, &#34;modelling_realm&#34;), (&#34;comments&#34;,
                                                                  &#34;variable_comments&#34;),
                          (&#34;table&#34;, &#34;table_identifier&#34;)],
        }
        to_merge_keys_patterns = {
            # (&#34;.+variable_groups&#34;, &#34;variable_groups&#34;)]
            &#34;opportunities&#34;: [(&#34;mips.*&#34;, &#34;mips&#34;), ]
        }
        to_sort_keys_content = {
            &#34;opportunities&#34;: [&#34;variable_groups&#34;, &#34;data_request_themes&#34;, &#34;experiment_groups&#34;, &#34;time_slice&#34;],
            &#34;experiment_groups&#34;: [&#34;experiments&#34;, ],
            &#34;variable_groups&#34;: [&#34;variables&#34;, &#34;mips&#34;]
        }
        from_list_to_string_keys_content = {
            &#34;opportunities&#34;: [&#34;lead_theme&#34;, ],
            &#34;physical_parameters&#34;: [&#34;cf_standard_name&#34;, ],
            &#34;table_identifiers&#34;: [&#34;cmip7_frequency&#34;, ],
            &#34;variables&#34;: [&#34;cell_methods&#34;, &#34;cmip6_frequency&#34;, &#34;cmip7_frequency&#34;, &#34;esm-bcv&#34;, &#34;physical_parameter&#34;,
                          &#34;spatial_shape&#34;, &#34;table_identifier&#34;, &#34;temporal_shape&#34;]
        }
        for subelt in sorted(list(content)):
            # Remove everything save records
            records = content[subelt].pop(&#34;records&#34;)
            for subkey in list(content[subelt]):
                del content[subelt][subkey]
            content[subelt].update(records)
            # Find out list of patterns to remove, rename, merge, sort...
            patterns_to_remove = to_remove_keys_patterns.get(subelt, list())
            patterns_to_remove.extend(default_patterns_to_remove)
            patterns_to_remove = [re.compile(elt)
                                  for elt in patterns_to_remove]
            patterns_to_rename = to_rename_keys_patterns.get(subelt, list())
            patterns_to_rename = [(re.compile(elt[0]), elt[1]) if not isinstance(
                elt[0], list) else elt for elt in patterns_to_rename]
            patterns_to_merge = to_merge_keys_patterns.get(subelt, list())
            patterns_to_merge = [(re.compile(elt[0]), elt[1])
                                 for elt in patterns_to_merge]
            for record_id in sorted(list(content[subelt])):
                # Remove unused keys
                list_keys = sorted(list(content[subelt][record_id]))
                list_keys_to_remove = [elt for elt in list_keys if
                                       any(patt.match(elt) is not None for patt in patterns_to_remove)]
                for key in list_keys_to_remove:
                    del content[subelt][record_id][key]
                # Rename needed keys
                list_keys = sorted(list(content[subelt][record_id]))
                for (patt, repl) in patterns_to_rename:
                    if isinstance(patt, list) and len(patt) == 0:
                        if repl in [&#34;esm-bcv&#34;, ]:
                            to_rename = [
                                elt for elt in list_keys if esm_bcv_regexp.match(elt) is not None]
                        else:
                            raise ValueError(
                                f&#34;Issue with patt void list with replacement {repl}.&#34;)
                    else:
                        to_rename = [
                            elt for elt in list_keys if patt.match(elt) is not None]
                    if len(to_rename) == 1:
                        content[subelt][record_id][repl] = content[subelt][record_id].pop(
                            to_rename[0])
                    elif len(to_rename) &gt; 1:
                        raise ValueError(
                            f&#34;Several keys ({to_rename}) match pattern {patt} in subelt {subelt}.&#34;)
                # Merge needed keys
                list_keys = sorted(list(content[subelt][record_id]))
                for (patt, repl) in patterns_to_merge:
                    to_merge = [
                        elt for elt in list_keys if patt.match(elt) is not None]
                    if len(to_merge) &gt; 0:
                        content[subelt][record_id][repl] = list()
                        for elts in to_merge:
                            if isinstance(content[subelt][record_id][elts], list):
                                content[subelt][record_id][repl].extend(
                                    content[subelt][record_id].pop(elts))
                            else:
                                content[subelt][record_id][repl].append(
                                    content[subelt][record_id].pop(elts))
                # Add keys if needed
                list_keys = sorted(list(set(content[subelt][record_id])))
                if &#34;name&#34; not in list_keys:
                    content[subelt][record_id][&#34;name&#34;] = &#34;undef&#34;
        # Filter on status if needed then remove linked keys
        variable_groups = set()
        experiment_groups = set()
        variables = set()
        experiments = set()
        subelt = &#34;opportunities&#34;
        for record_id in sorted(list(content[subelt])):
            if content[subelt][record_id].get(&#34;status&#34;) not in [&#34;Accepted&#34;, &#34;Under review&#34;, None]:
                del content[subelt][record_id]
            else:
                variable_groups = variable_groups | set(
                    content[subelt][record_id].get(&#34;variable_groups&#34;, list()))
                experiment_groups = experiment_groups | set(
                    content[subelt][record_id].get(&#34;experiment_groups&#34;, list()))
        subelt = &#34;variable_groups&#34;
        for record_id in sorted(list(content[subelt])):
            if record_id not in variable_groups:
                del content[subelt][record_id]
            else:
                variables = variables | set(
                    content[subelt][record_id].get(&#34;variables&#34;, list()))
        subelt = &#34;experiment_groups&#34;
        for record_id in sorted(list(content[subelt])):
            if record_id not in experiment_groups:
                del content[subelt][record_id]
            elif content[subelt][record_id].get(&#34;status&#34;) in [&#34;Junk&#34;, ]:
                del content[subelt][record_id]
                for op in list(content[&#34;opportunities&#34;]):
                    if record_id in content[&#34;opportunities&#34;][op][&#34;experiment_groups&#34;]:
                        content[&#34;opportunities&#34;][op][&#34;experiment_groups&#34;].remove(
                            record_id)
            else:
                experiments = experiments | set(
                    content[subelt][record_id].get(&#34;experiments&#34;, list()))
        subelt = &#34;variables&#34;
        for record_id in sorted(list(set(content[subelt]) - variables)):
            del content[subelt][record_id]
        subelt = &#34;experiments&#34;
        for record_id in sorted(list(set(content[subelt]) - experiments)):
            del content[subelt][record_id]
        for subelt in list(content):
            for record_id in list(content[subelt]):
                for key in [key for key in list(content[subelt][record_id])
                            if re.compile(r&#34;.*status.*&#34;).match(key) is not None]:
                    del content[subelt][record_id][key]
        # Add uid if needed
        record_to_uid_index = dict()
        for subelt in sorted(list(content)):
            for record_id in sorted(list(content[subelt]),
                                    key=lambda record_id: &#34;|&#34;.join([content[subelt][record_id].get(&#34;name&#34;),
                                                                    content[subelt][record_id].get(
                                                                        &#34;uid&#34;, &#34;undef&#34;),
                                                                    record_id])):
                if &#34;uid&#34; not in content[subelt][record_id]:
                    uid = default_template.format(default_count)
                    content[subelt][record_id][&#34;uid&#34;] = uid
                    default_count += 1
                    logger.debug(
                        f&#34;Undefined uid for element {os.sep.join([subelt, &#39;records&#39;, record_id])}, set {uid}&#34;)
                uid = content[subelt][record_id].pop(&#34;uid&#34;)
                if uid.endswith(os.linesep):
                    logger.debug(
                        f&#34;uid of element type {subelt} and record id {record_id} endswith &#39;\\n&#39;.&#34;)
                    uid = uid.rstrip(os.linesep)
                record_to_uid_index[record_id] = (uid, subelt)
                content[subelt][uid] = content[subelt].pop(record_id)
        # Replace record_id by uid
        logger.debug(&#34;Replace record ids by uids&#34;)
        to_remove_entries = defaultdict(list)
        content_string = json.dumps(content)
        for (record_id, (uid, subelt)) in record_to_uid_index.items():
            (content_string, nb) = re.subn(
                f&#39;&#34;{record_id}&#34;&#39;, f&#39;&#34;link::{uid}&#34;&#39;, content_string)
            if nb == 0:
                to_remove_entries[subelt].append((record_id, uid))
        for record_id, _ in to_remove_entries[&#34;opportunities&#34;]:
            del record_to_uid_index[record_id]
        del to_remove_entries[&#34;opportunities&#34;]
        content = json.loads(content_string)
        # Remove unused entries
        for subelt in to_remove_entries:
            for (record_id, uid) in to_remove_entries[subelt]:
                del content[subelt][uid]
                del record_to_uid_index[record_id]
        # Tidy the content once again
        content_str = json.dumps(content)
        to_remove_entries = defaultdict(list)
        for (record_id, (uid, subelt)) in record_to_uid_index.items():
            nb = content_str.count(uid)
            if nb &lt; 2:
                to_remove_entries[subelt].append(uid)
        for subelt in to_remove_entries:
            for uid in to_remove_entries[subelt]:
                del content[subelt][uid]
        # Sort content of needed keys
        for subelt in sorted(list(content)):
            patterns_to_sort = to_sort_keys_content.get(subelt, list())
            patterns_to_sort = [re.compile(elt) for elt in patterns_to_sort]
            patterns_to_reshape = from_list_to_string_keys_content.get(
                subelt, list())
            patterns_to_reshape = [re.compile(elt)
                                   for elt in patterns_to_reshape]
            for uid in sorted(list(content[subelt])):
                # Sort content of needed keys
                list_keys = sorted(list(content[subelt][uid]))
                list_keys_to_sort = [elt for elt in list_keys
                                     if any(patt.match(elt) is not None for patt in patterns_to_sort)]
                for key in list_keys_to_sort:
                    content[subelt][uid][key] = sorted(
                        list(set(content[subelt][uid][key])))
                # Reshape content if needed
                list_keys_to_reshape = [elt for elt in list_keys
                                        if any(patt.match(elt) is not None for patt in patterns_to_reshape)]
                for key in list_keys_to_reshape:
                    if isinstance(content[subelt][uid][key], list):
                        if len(content[subelt][uid][key]) == 1:
                            content[subelt][uid][key] = content[subelt][uid][key][0]
                        elif len(content[subelt][uid][key]) == 0:
                            logger.warning(
                                f&#34;Remove void key {key} from id {uid} of element type {subelt}&#34;)
                            del content[subelt][uid][key]
                        else:
                            logger.error(
                                f&#34;Could not reshape key {key} from id {uid} of element type {subelt}: contains several elements&#34;)
                            raise ValueError(
                                f&#34;Could not reshape key {key} from id {uid} of element type {subelt}: contains several elements&#34;)
                    elif isinstance(content[subelt][uid][key], str):
                        logger.warning(
                            f&#34;Could not reshape key {key} from id {uid} of element type {subelt}: already a string&#34;)
                    else:
                        logger.error(
                            f&#34;Could not reshape key {key} from id {uid} of element type {subelt}: not a list&#34;)
                        raise ValueError(
                            f&#34;Could not reshape key {key} from id {uid} of element type {subelt}: not a list&#34;)
        return content
    elif isinstance(content, dict):
        logger.error(&#34;Deal with one base content dict.&#34;)
        raise ValueError(&#34;Deal with one base content dict.&#34;)
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Transform a one base export content to:
- remove unused keys which could create circle import later
- harmonise some entries
- reshape entries if needed
- remove elements which are not used
- filter content on status
:param dict content: one base content export (direct export or created from <code><a title="stable.content.dump_transformation.transform_content_three_bases" href="#stable.content.dump_transformation.transform_content_three_bases">transform_content_three_bases()</a></code>
:return dict: the transform content</p></div>
</dd>
<dt id="stable.content.dump_transformation.transform_content_three_bases"><code class="name flex">
<span>def <span class="ident">transform_content_three_bases</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_content_three_bases(content):
    &#34;&#34;&#34;
    Transform the several bases export content into something similar to a one base export content.
    To do that, the content of the different entries of the input dictionary are copied to a single dictionary.
    The record ids are also harmonised through the different bases.
    :param dict content: input dictionary containing the different databases
    :return dict: dictionary containing the content of the different databases
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(content, dict) and len(content) &gt; 2:
        new_content = dict()
        opportunity_table = [elt for elt in list(
            content) if &#34;opportunities&#34; in elt.lower()][0]
        variables_table = [elt for elt in list(
            content) if &#34;variables&#34; in elt.lower()][0]
        physical_parameters_table = [elt for elt in list(
            content) if &#34;parameters&#34; in elt.lower()][0]
        # Copy the bases
        old_variables_content = content[opportunity_table].pop(&#34;Variables&#34;)
        old_physical_parameters_content = content[variables_table].pop(
            &#34;Physical Parameter&#34;)
        new_content[&#34;Opportunity/variable Group Comments&#34;] = content[opportunity_table].pop(
            &#34;Comment&#34;)
        new_content[&#34;Experiments&#34;] = content[opportunity_table].pop(
            &#34;Experiment&#34;)
        new_content[&#34;MIPs&#34;] = content[opportunity_table].pop(&#34;MIP&#34;)
        for elt in list(content[opportunity_table]):
            new_content[elt] = content[opportunity_table].pop(elt)
        new_content[&#34;Variables&#34;] = content[variables_table].pop(&#34;Variable&#34;)
        new_content[&#34;Coordinates and Dimensions&#34;] = content[variables_table].pop(
            &#34;Coordinate or Dimension&#34;)
        new_content[&#34;Variable Comments&#34;] = content[variables_table].pop(
            &#34;Comment&#34;)
        if &#34;Modeling Realm&#34; in content[variables_table]:
            new_content[&#34;Modelling Realm&#34;] = content[variables_table].pop(
                &#34;Modeling Realm&#34;)
        for elt in list(content[variables_table]):
            new_content[elt] = content[variables_table].pop(elt)
        new_content[&#34;Physical Parameter Comments&#34;] = content[physical_parameters_table].pop(
            &#34;Comment&#34;)
        new_content[&#34;Physical Parameters&#34;] = content[physical_parameters_table].pop(
            &#34;Physical Parameter&#34;)
        new_content[&#34;CF Standard Names&#34;] = content[physical_parameters_table].pop(
            &#34;CF Standard Name&#34;)
        for elt in list(content[physical_parameters_table]):
            new_content[elt] = content[physical_parameters_table].pop(elt)
        # Correct record id through several bases
        old_variables_ids = {record_id: value[&#34;Compound Name&#34;] for (record_id, value) in
                             old_variables_content[&#34;records&#34;].items()}
        new_variables_ids = {value[&#34;Compound Name&#34;]: record_id for (record_id, value) in
                             new_content[&#34;Variables&#34;][&#34;records&#34;].items()}
        for var_group_id in list(new_content[&#34;Variable Group&#34;][&#34;records&#34;]):
            new_content[&#34;Variable Group&#34;][&#34;records&#34;][var_group_id][&#34;Variables&#34;] = \
                [new_variables_ids[old_variables_ids[elt]] for elt in
                 new_content[&#34;Variable Group&#34;][&#34;records&#34;][var_group_id][&#34;Variables&#34;]]
        old_physical_parameters_ids = {record_id: value[&#34;Name&#34;] for (record_id, value) in
                                       old_physical_parameters_content[&#34;records&#34;].items()}
        new_physical_parameters_ids = {value[&#34;Name&#34;]: record_id for (record_id, value) in
                                       new_content[&#34;Physical Parameters&#34;][&#34;records&#34;].items()}
        for var_id in list(new_content[&#34;Variables&#34;][&#34;records&#34;]):
            if &#34;Physical Parameter&#34; not in new_content[&#34;Variables&#34;][&#34;records&#34;][var_id]:
                logger.debug(
                    f&#34;Remove Variables record ID {var_id}, no &#39;Physical Parameter&#39; field defined.&#34;)
                del new_content[&#34;Variables&#34;][&#34;records&#34;][var_id]
            else:
                new_content[&#34;Variables&#34;][&#34;records&#34;][var_id][&#34;Physical Parameter&#34;] = \
                    [new_physical_parameters_ids[old_physical_parameters_ids[elt]] for elt in
                     new_content[&#34;Variables&#34;][&#34;records&#34;][var_id][&#34;Physical Parameter&#34;]]
        # Harmonise record ids through bases
        logger.info(&#34;Harmonise bases content record ids&#34;)
        content_str = json.dumps(new_content)
        for id in sorted(list(old_variables_ids)):
            content_str = re.sub(
                f&#39;&#34;{id}&#34;&#39;, f&#39;&#34;{new_variables_ids[old_variables_ids[id]]}&#34;&#39;, content_str)
        for id in sorted(list(old_physical_parameters_ids)):
            content_str = re.sub(
                f&#39;&#34;{id}&#34;&#39;, f&#39;&#34;{new_physical_parameters_ids[old_physical_parameters_ids[id]]}&#34;&#39;, content_str)
        new_content = json.loads(content_str)
        # Return the content
        return {&#34;Data Request&#34;: new_content}
    elif isinstance(content, dict):
        logger.error(f&#34;Deal with several bases dict.&#34;)
        raise ValueError(f&#34;Deal with several bases dict.&#34;)
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Transform the several bases export content into something similar to a one base export content.
To do that, the content of the different entries of the input dictionary are copied to a single dictionary.
The record ids are also harmonised through the different bases.
:param dict content: input dictionary containing the different databases
:return dict: dictionary containing the content of the different databases</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stable.content" href="index.html">stable.content</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="stable.content.dump_transformation.correct_dictionaries" href="#stable.content.dump_transformation.correct_dictionaries">correct_dictionaries</a></code></li>
<li><code><a title="stable.content.dump_transformation.correct_key_string" href="#stable.content.dump_transformation.correct_key_string">correct_key_string</a></code></li>
<li><code><a title="stable.content.dump_transformation.get_transformed_content" href="#stable.content.dump_transformation.get_transformed_content">get_transformed_content</a></code></li>
<li><code><a title="stable.content.dump_transformation.split_content_one_base" href="#stable.content.dump_transformation.split_content_one_base">split_content_one_base</a></code></li>
<li><code><a title="stable.content.dump_transformation.transform_content" href="#stable.content.dump_transformation.transform_content">transform_content</a></code></li>
<li><code><a title="stable.content.dump_transformation.transform_content_one_base" href="#stable.content.dump_transformation.transform_content_one_base">transform_content_one_base</a></code></li>
<li><code><a title="stable.content.dump_transformation.transform_content_three_bases" href="#stable.content.dump_transformation.transform_content_three_bases">transform_content_three_bases</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
